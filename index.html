<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Matrix Style Blogging</title>
  <!-- Add Prism CSS and JS files before the existing styles -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Set basic page style and matrix theme colors */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #1a1a1a;
      font-family: 'JetBrains Mono', monospace;
      color: #e0e0e0;
    }
    /* Canvas for the matrix animation */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }
    /* Container for blog posts (positioned over the canvas) */
    #blog-container {
      position: absolute;
      top: calc(5px + env(safe-area-inset-top));
      left: calc(5px + env(safe-area-inset-left));
      right: calc(5px + env(safe-area-inset-right));
      bottom: calc(5px + env(safe-area-inset-bottom));
      overflow-y: auto;
      z-index: 1;
      pointer-events: none;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .blog-post {
      position: relative;
      margin: 25px;
      padding: 20px;
      background: rgba(36, 36, 36, 0.7);
      border: 1px solid rgba(157, 78, 221, 0.2);
      border-radius: 12px;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 6px 15px rgba(157, 78, 221, 0.15);
      transition: all 0.3s ease;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }
    .blog-post.selected {
      border: 1px solid rgba(157, 78, 221, 0.6);
      box-shadow: 0 0 15px rgba(157, 78, 221, 0.3);
    }
    .blog-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(157, 78, 221, 0.2);
    }
    .blog-post h3 {
      font-size: 1.8em;
      margin: 0 70px 15px 0;
      color: #9d4edd;
      text-shadow: 0 0 5px rgba(157, 78, 221, 0.5);
      letter-spacing: 1px;
    }
    .blog-post strong {
      position: absolute;
      top: auto;  /* Remove top positioning */
      bottom: 10px;  /* Position at bottom */
      left: 20px;  /* Position at left */
      right: auto;  /* Remove right positioning */
      display: inline-block;
      font-size: 0.9em;
      opacity: 0.8;
    }
    .blog-post {
      padding-bottom: 40px;  /* Add padding for timestamp */
    }
    .copy-btn {
      bottom: 8px;  /* Align with timestamp */
    }
    .blog-post-modal strong {
      position: absolute;
      top: auto;
      bottom: 15px;
      left: 25px;
      right: auto;
      font-size: 0.9em;
      opacity: 0.8;
    }
    .blog-post-modal {
      padding-bottom: 50px;  /* Add padding for timestamp */
    }
    .blog-post-modal .copy-btn {
      bottom: 13px;
    }
    /* Compose modal for writing new blog posts */
    #compose-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(36, 36, 36, 0.8);
      padding: 25px;
      border: 1px solid rgba(157, 78, 221, 0.3);
      display: none;
      z-index: 2;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 0 20px rgba(157, 78, 221, 0.3);
      width: 90%;
      max-width: 600px;
      max-height: 90vh;  /* Limit height to 90% of viewport height */
      overflow-y: auto;  /* Allow scrolling if content is too tall */
      box-sizing: border-box;
    }
    #compose-modal input {
      width: 100%;
      padding: 12px;
      margin-bottom: 15px;
      background: rgba(26, 26, 26, 0.7);
      color: #e0e0e0;
      border: 1px solid rgba(157, 78, 221, 0.3);
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      border-radius: 10px;
      outline: none;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: inset 0 0 10px rgba(157, 78, 221, 0.1);
      box-sizing: border-box;
    }
    #compose-modal textarea {
      width: 100%;
      height: 300px;
      background: rgba(26, 26, 26, 0.7);
      color: #e0e0e0;
      border: 1px solid rgba(157, 78, 221, 0.3);
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      padding: 15px;
      resize: none;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: inset 0 0 10px rgba(157, 78, 221, 0.1);
      border-radius: 10px;
      outline: none;
      box-sizing: border-box;
      margin-bottom: 15px;
    }
    /* Add focus state styling */
    #compose-modal input:focus,
    #compose-modal textarea:focus {
      border-color: #9d4edd;
      box-shadow: inset 0 0 15px rgba(157, 78, 221, 0.2), 0 0 15px rgba(157, 78, 221, 0.2);
    }
    #compose-modal p {
      color: #9d4edd !important;
      text-shadow: 0 0 5px rgba(157, 78, 221, 0.3);
    }
    /* Instruction overlay at the bottom */
    #instructions {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(36, 36, 36, 0.8);
      padding: 5px 10px;
      border: 1px solid rgba(157, 78, 221, 0.3);
      font-size: 14px;
      z-index: 3;
      color: #9d4edd;
      text-shadow: 0 0 5px rgba(157, 78, 221, 0.3);
    }
    

    /* Added vanish animation for mobile instruction messages/hints */
    #instructions.vanish {
      animation: vanish-out 1s forwards;
    }
    @keyframes vanish-out {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
    /* Added fade-in effect for new blog posts */
    .new-post {
      opacity: 0;
      animation: fadeIn 1s forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Slide out animation for blog deletion */
    .slide-out-left {
      transform: translateX(-100%);
      opacity: 0;
    }

    /* Help modal styling */
    #help-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 26, 26, 0.9);
      display: none;
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }
    #help-content {
      background: rgba(36, 36, 36, 0.8);
      border: 1px solid rgba(157, 78, 221, 0.3);
      padding: 20px;
      border-radius: 8px;
      color: #e0e0e0;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
    }
    #help-content h2 {
      margin-top: 0;
    }

    /* Back-to-top button styling */
    #back-to-top {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(36, 36, 36, 0.8);
      border: 1px solid rgba(157, 78, 221, 0.3);
      color: #9d4edd;
      font-family: 'JetBrains Mono', monospace;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10000;
    }

    /* Add these styles for the expanded blog post modal */
    .blog-post-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      background: rgba(36, 36, 36, 0.8);
      border: 1px solid rgba(157, 78, 221, 0.3);
      border-radius: 15px;
      padding: 25px;
      z-index: 1000;
      overflow-y: auto;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(157, 78, 221, 0.3);
      display: none;
      box-sizing: border-box;
    }

    .blog-post-modal h3 {
      font-size: 2em;
      margin: 0 70px 20px 0;
      color: #9d4edd;
      text-shadow: 0 0 8px rgba(157, 78, 221, 0.5);
      letter-spacing: 1px;
    }

    .blog-post-modal .content {
      font-size: 1.1em;
      line-height: 1.6;
    }

    /* Overlay for expanded blog post */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      z-index: 999;
      display: none;
    }

    @media (max-width: 600px) {
      #compose-modal {
        padding: 15px;
        width: 95%;
        top: 50%;
        max-height: 80vh;  /* Slightly smaller on mobile */
      }

      #compose-modal input,
      #compose-modal textarea {
        background: rgba(26, 26, 26, 0.7) !important;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
        color: #e0e0e0;
        border: 1px solid rgba(157, 78, 221, 0.3);
        font-family: 'JetBrains Mono', monospace;
        border-radius: 10px;
        width: 100%;
        box-sizing: border-box;
        outline: none;
        box-shadow: inset 0 0 10px rgba(157, 78, 221, 0.1);
      }

      #compose-modal input {
        padding: 12px;
        margin-bottom: 15px;
        font-size: 16px;
        -webkit-appearance: none;  /* Remove default iOS styling */
        appearance: none;
      }

      #compose-modal textarea {
        height: 150px;
        padding: 12px;
        font-size: 16px;
        resize: none;
        margin-bottom: 10px;
        -webkit-appearance: none;  /* Remove default iOS styling */
        appearance: none;
      }

      /* Add focus state styling */
      #compose-modal input:focus,
      #compose-modal textarea:focus {
        border-color: #9d4edd;
        box-shadow: inset 0 0 15px rgba(157, 78, 221, 0.2), 0 0 15px rgba(157, 78, 221, 0.2);
      }

      .blog-post {
        margin: 15px 10px;
        padding: 15px;
      }

      .blog-post h3 {
        font-size: 1.5em;
      }

      .blog-post {
        padding-bottom: 40px;  /* Add more padding at bottom to accommodate timestamp */
      }

      /* Adjust copy button position for mobile */
      .copy-btn {
        bottom: 8px;  /* Align with timestamp */
      }

      /* Also update modal timestamp position for consistency */
      .blog-post-modal strong {
        position: absolute;
        top: auto;
        bottom: 15px;
        left: 25px;
        right: auto;
      }

      .blog-post-modal {
        padding-bottom: 50px;  /* Add more padding at bottom */
      }

      .blog-post-modal .copy-btn {
        bottom: 13px;
      }
    }

    /* Add styles for code blocks */
    pre[class*="language-"] {
      background: rgba(26, 26, 26, 0.7) !important;
      border: 1px solid rgba(157, 78, 221, 0.2);
      border-radius: 8px;
      margin: 1em 0;
      padding: 1em;
      overflow: auto;
    }

    code[class*="language-"] {
      text-shadow: none !important;
      background: none !important;
      font-family: 'JetBrains Mono', monospace !important;
      font-size: 14px;
    }

    /* Customize Prism theme colors to match matrix theme */
    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
      color: #9d4edd80 !important;
    }

    .token.function,
    .token.class-name {
      color: #c77dff !important;
    }

    .token.keyword,
    .token.operator {
      color: #9d4edd !important;
    }

    .token.string {
      color: #e0aaff !important;
    }

    .token.number {
      color: #ddb4ff !important;
    }

    /* Style for line numbers */
    .line-numbers .line-numbers-rows {
      border-right: 1px solid rgba(157, 78, 221, 0.2) !important;
    }

    .line-numbers-rows > span:before {
      color: rgba(157, 78, 221, 0.4) !important;
    }

    /* Replace .download-btn with .copy-btn */
    .copy-btn {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(36, 36, 36, 0.8);
      border: 1px solid rgba(157, 78, 221, 0.3);
      color: #e0e0e0;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      transition: all 0.3s ease;
      z-index: 2;
    }

    .copy-btn:hover {
      background: rgba(157, 78, 221, 0.1);
      box-shadow: 0 0 10px rgba(157, 78, 221, 0.3);
    }

    .copy-btn.loading {
      pointer-events: none;
      opacity: 0.7;
      animation: pulse 1s infinite;
    }

    /* Add success animation */
    .copy-btn.success {
      background: rgba(157, 78, 221, 0.2);
      animation: success-pulse 0.5s;
    }

    @keyframes success-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    /* Fullscreen button styling */
    #fullscreen-btn {
      display: none; /* Hidden by default */
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: none;
      border: none;
      color: #9d4edd;
      font-size: 24px;
      cursor: pointer;
      z-index: 1000;
      padding: 10px;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    #fullscreen-btn:hover {
      opacity: 1;
    }

    /* Show fullscreen button only on mobile */
    @media (max-width: 600px) {
      #fullscreen-btn {
        display: block;
      }
    }
  </style>
</head>
<body>
  <!-- Matrix background canvas -->
  <canvas id="matrixCanvas"></canvas>

  <!-- Container for blog posts -->
  <div id="blog-container"></div>
  
  <!-- Compose modal for new blog post (removed mobile buttons below) -->
  <div id="compose-modal">
    <input type="text" id="compose-title" placeholder="Blog title..." />
    <textarea id="compose-text" placeholder="Write your blog post here..."></textarea>
    <!-- Updated prompt for mobile (will be overwritten by JS on mobile) -->
    <p style="color:#9d4edd;">Press Ctrl+Enter to post, Esc to cancel.</p>
    <!-- Removed mobile compose buttons
    <div id="compose-buttons">
      <button id="post-button">Post</button>
      <button id="cancel-button">Cancel</button>
    </div>
    -->
  </div>
  
  <!-- Instruction overlay -->
  <div id="instructions">Press 'N' for new blog post</div>
  
  <!-- Removed mobile new post button
  <button id="new-post-button">New Post</button>
  -->
  
  <!-- Help modal overlay -->
  <div id="help-modal">
    <div id="help-content">
      <h2>Help / Instructions</h2>
      <ul>
        <li><strong>N</strong>: New blog post</li>
        <li><strong>Ctrl + Enter</strong>: Post the blog</li>
        <li><strong>Esc</strong>: Cancel compose or close help modal</li>
        <li><strong>E</strong>: Edit selected blog post</li>
        <li><strong>Arrow Up/Down</strong>: Navigate blog posts</li>
        <li><strong>Ctrl+D</strong>: Delete selected blog post (PC)</li>
        <li><strong>Swipe left</strong>: Delete post (Mobile)</li>
        <li><strong>?</strong>: Toggle help modal</li>
      </ul>
      <p>Tap anywhere or press Esc to close.</p>
    </div>
  </div>
  
  <!-- Back-to-top button -->
  <button id="back-to-top">Top</button>
  
  <!-- Modal overlay and expanded blog post container -->
  <div class="modal-overlay"></div>
  <div class="blog-post-modal"></div>
  
  <!-- Add Prism.js and plugins before closing body tag -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <!-- Add common language support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>

  <!-- Add html2canvas library before closing body tag (after other scripts) -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <!-- Simple fullscreen button with arrow icon -->
  <button id="fullscreen-btn">â‡±</button>

  <script>
    // Replace the entire matrix animation code with this particle animation
    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');

    // Show canvas again and style it
    canvas.style.display = 'block';
    canvas.style.opacity = '0.9';

    // Particle class
    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        // Use the actual viewport dimensions instead of canvas dimensions
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        this.size = Math.random() * 4 + 2;
        this.speedX = Math.random() * 0.3 - 0.15;
        this.speedY = Math.random() * 0.3 - 0.15;
        this.opacity = Math.random() * 0.3 + 0.6;
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;

        // Wrap around screen using viewport dimensions
        if (this.x < 0) this.x = window.innerWidth;
        if (this.x > window.innerWidth) this.x = 0;
        if (this.y < 0) this.y = window.innerHeight;
        if (this.y > window.innerHeight) this.y = 0;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(157, 78, 221, ${this.opacity})`;
        ctx.fill();
      }
    }

    // Create particle array
    const particles = [];
    const particleCount = 100;

    // Initialize particles
    for (let i = 0; i < particleCount; i++) {
      particles.push(new Particle());
    }

    // Animation function
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw particles
      particles.forEach(particle => {
        particle.update();
        particle.draw();
      });
      
      // Draw connecting lines between nearby particles
      particles.forEach((p1, index) => {
        for (let j = index + 1; j < particles.length; j++) {
          const p2 = particles[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 150) {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(157, 78, 221, ${0.4 * (1 - distance/150)})`;
            ctx.lineWidth = 0.8;
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
      });
      
      requestAnimationFrame(animate);
    }

    // Handle canvas resize
    function resizeCanvas() {
      // Get the device pixel ratio for sharper rendering on high DPI displays
      const dpr = window.devicePixelRatio || 1;
      
      // Set actual dimensions of the canvas to match window size
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      
      // Scale the context to ensure correct drawing operations
      ctx.scale(dpr, dpr);
      
      // Set CSS dimensions to ensure it covers the full viewport
      canvas.style.width = `${window.innerWidth}px`;
      canvas.style.height = `${window.innerHeight}px`;
    }

    // Update the canvas CSS styles
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.opacity = '0.3';
    canvas.style.pointerEvents = 'none';

    window.addEventListener('resize', () => {
      resizeCanvas();
      // Reset particles on resize
      particles.forEach(particle => particle.reset());
    });

    // Initial setup
    resizeCanvas();
    animate();

    // Blog functionality
    const blogContainer = document.getElementById('blog-container');
    const composeModal = document.getElementById('compose-modal');
    const composeText = document.getElementById('compose-text');
    const composeTitle = document.getElementById('compose-title');

    // NEW: Add persistence using localStorage
    let blogPosts = [];
    const STORAGE_KEY = 'matrix_blog_posts';

    function saveBlogPosts() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(blogPosts));
    }

    function createBlogPostElement(postData) {
      const post = document.createElement('div');
      post.classList.add('blog-post', 'new-post');
      post.dataset.id = postData.id;
      post.innerHTML = `
        <strong>${postData.time}</strong>
        <h3>${postData.title}</h3>
        ${postData.content}
        <button class="copy-btn">Copy</button>
      `;

      // Add copy button event listener
      const copyBtn = post.querySelector('.copy-btn');
      copyBtn.addEventListener('click', (e) => copyBlogPost(post, e));

      // Add click event so user can select the post with a mouse click
      post.addEventListener('click', function(e) {
        e.stopPropagation();
        selectPost(post);
        expandBlogPost(post);
      });
      // Remove the fade-in class after the animation completes
      post.addEventListener('animationend', function() {
        post.classList.remove('new-post');
      });
      // Add swipe-left detection for mobile devices to delete a blog post
      if (window.innerWidth < 600) {
        let touchStartX = 0;
        post.addEventListener('touchstart', function(e) {
          touchStartX = e.changedTouches[0].clientX;
        });
        post.addEventListener('touchend', function(e) {
          let touchEndX = e.changedTouches[0].clientX;
          if (touchStartX - touchEndX > 50) {  // if swiped left more than 50px
            // Add slide-out animation then delete the blog post after the transition ends
            post.classList.add('slide-out-left');
            post.addEventListener('transitionend', function() {
              const nextSelection = post.nextElementSibling || post.previousElementSibling;
              const idToDelete = post.dataset.id;
              blogPosts = blogPosts.filter(p => p.id != idToDelete);
              saveBlogPosts();
              if (selectedPost === post) {
                selectPost(nextSelection);
              }
              if (post.parentElement) {
                post.parentElement.removeChild(post);
              }
            }, { once: true });
          }
        });
      }
      return post;
    }

    function loadBlogPosts() {
      const savedPosts = localStorage.getItem(STORAGE_KEY);
      if (savedPosts) {
        blogPosts = JSON.parse(savedPosts);
        blogPosts.forEach(postData => {
          const postElement = createBlogPostElement(postData);
          blogContainer.prepend(postElement);
          Prism.highlightAllUnder(postElement);
        });
      }
    }

    // Global variables for selection and edit mode
    let selectedPost = null;
    let editMode = false;
    let editTarget = null;

    // Helper to update selected post
    function selectPost(post) {
      if (selectedPost) {
        selectedPost.classList.remove('selected');
      }
      selectedPost = post;
      if (selectedPost) {
        selectedPost.classList.add('selected');
        // Scroll the selected post into view smoothly
        selectedPost.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // Open compose modal (clears previous text)
    function openComposeModal() {
      editMode = false;
      editTarget = null;
      composeModal.style.display = 'block';
      composeTitle.value = '';
      composeText.value = '';
      composeTitle.focus();
    }

    // Close compose modal
    function closeComposeModal() {
      composeModal.style.display = 'none';
      editMode = false;
      editTarget = null;
    }

    // UPDATED: Add a new blog post with a timestamp and update persistent storage
    function addBlogPost(title, text) {
      const id = Date.now();
      const time = new Date().toLocaleTimeString();
      const formattedContent = formatCodeBlocks(text);
      const postData = { id, time, title, content: formattedContent };
      blogPosts.push(postData);
      const post = createBlogPostElement(postData);
      blogContainer.prepend(post);
      saveBlogPosts();
      
      // Re-initialize Prism highlighting for the new post
      Prism.highlightAllUnder(post);
    }

    // Update the edit functionality in the keydown listener
    function getPostContent(post) {
      // Get raw content by removing title and timestamp
      const content = Array.from(post.childNodes)
        .filter(node => !node.querySelector('h3') && !node.querySelector('strong'))
        .map(node => {
          if (node.tagName === 'PRE') {
            // Handle code blocks - convert back to markdown format
            const code = node.querySelector('code');
            const language = Array.from(code.classList)
              .find(cls => cls.startsWith('language-'))
              ?.replace('language-', '') || 'plaintext';
            return `\`\`\`${language}\n${code.textContent}\n\`\`\``;
          } else {
            // Handle regular text - convert <br> back to newlines
            return node.textContent.replace(/<br\s*\/?>/g, '\n');
          }
        })
        .join('\n');
      
      return content;
    }

    // Update the keydown event listener
    document.addEventListener('keydown', function(e) {
      // Handle Escape key regardless of focus
      if (e.key === 'Escape') {
        if (composeModal.style.display === 'block') {
          closeComposeModal();
          return;
        } else if (helpModal.style.display === 'flex') {
          helpModal.style.display = 'none';
          return;
        } else if (blogPostModal.style.display === 'block') {
          closeExpandedPost();
          return;
        } else if (selectedPost) {
          selectedPost.classList.remove('selected');
          selectedPost = null;
          return;
        }
      }

      // Handle Ctrl+Enter for posting
      if (e.key === 'Enter' && e.ctrlKey) {
        e.preventDefault();
        if (composeModal.style.display === 'block') {
          const title = composeTitle.value.trim();
          const text = composeText.value.trim();
          if (title && text) {
            if (editMode && editTarget) {
              // ... existing edit mode code ...
            } else {
              addBlogPost(title, text);
            }
            closeComposeModal();
            editMode = false;
            editTarget = null;
            saveBlogPosts();
          }
        }
      }

      // Only handle other shortcuts if not in input/textarea
      if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        if (e.key.toLowerCase() === 'n') {
          e.preventDefault();
          editMode = false;
          editTarget = null;
          composeModal.style.display = 'block';
          composeTitle.value = '';
          composeText.value = '';
          composeTitle.focus();
        } else if (e.key === 'ArrowDown') {
          // Select the next blog post
          if (selectedPost && selectedPost.nextElementSibling) {
            selectPost(selectedPost.nextElementSibling);
          } else if (!selectedPost && blogContainer.firstElementChild) {
            selectPost(blogContainer.firstElementChild);
          }
        } else if (e.key === 'ArrowUp') {
          // Select the previous blog post
          if (selectedPost && selectedPost.previousElementSibling) {
            selectPost(selectedPost.previousElementSibling);
          } else if (!selectedPost && blogContainer.lastElementChild) {
            selectPost(blogContainer.lastElementChild);
          }
        } else if (e.key === 'Delete' || (e.ctrlKey && e.key.toLowerCase() === 'd')) {
          e.preventDefault();
          // Delete the selected blog post and update persistent storage
          if (selectedPost) {
            const nextSelection = selectedPost.nextElementSibling || selectedPost.previousElementSibling;
            const idToDelete = selectedPost.dataset.id;
            blogPosts = blogPosts.filter(post => post.id != idToDelete);
            selectedPost.parentElement.removeChild(selectedPost);
            saveBlogPosts();
            selectPost(nextSelection);
          }
        } else if (e.key.toLowerCase() === 'e') {
          // Edit the selected blog post
          if (selectedPost) {
            editMode = true;
            editTarget = selectedPost;
            const title = selectedPost.querySelector('h3').textContent;
            const content = getPostContent(selectedPost);
            
            composeTitle.value = title;
            composeText.value = content;
            composeModal.style.display = 'block';
            composeTitle.focus();
          }
        }
      }
    });

    // Load persisted blog posts on page load
    loadBlogPosts();

    // DOUBLE TAP DETECTION for MOBILE DEVICES
    if (window.innerWidth < 600) {
      // Update instructions and modal prompt for mobile
      document.getElementById('instructions').textContent = 'Double tap to compose/post a blog';
      const modalPrompt = composeModal.querySelector('p');
      modalPrompt.textContent = 'Double tap to post, Esc to cancel';
      
      // Vanish the instructions overlay after 2 seconds
      setTimeout(() => {
        document.getElementById('instructions').classList.add('vanish');
      }, 2000);
      // Also vanish the modal prompt (if initially visible) after 2 seconds
      setTimeout(() => {
        modalPrompt.classList.add('vanish');
      }, 2000);
      
      let tapCount = 0;
      let tapTimer = null;
      document.addEventListener('touchend', function(e) {
        tapCount++;
        if (tapTimer) {
          clearTimeout(tapTimer);
        }
        tapTimer = setTimeout(() => {
          if (tapCount === 2) {
            // Double tap detected: compose or post a blog
            if (composeModal.style.display === 'block') {
              const title = composeTitle.value.trim();
              const text = composeText.value.trim();
              if (title && text) {
                if (editMode && editTarget) {
                  const id = editTarget.dataset.id;
                  const time = new Date().toLocaleTimeString();
                  editTarget.innerHTML = `
                    <strong>${time}</strong>
                    <h3>${title}</h3>
                    ${text.replace(/\n/g, '<br>')}
                  `;
                  const post = blogPosts.find(post => post.id == id);
                  if (post) {
                    post.time = time;
                    post.title = title;
                    post.content = text;
                  }
                } else {
                  addBlogPost(title, text);
                }
              }
              closeComposeModal();
              editMode = false;
              editTarget = null;
              saveBlogPosts();
            } else {
              // If modal is not open, open compose modal for a new post
              editMode = false;
              editTarget = null;
              openComposeModal();
            }
          }
          tapCount = 0;
          tapTimer = null;
        }, 300);
      });
    }

    // Help modal behavior
    const helpModal = document.getElementById('help-modal');
    document.addEventListener('keydown', function(e) {
      if (e.key === '?') {
        // Toggle help modal visibility
        if (helpModal.style.display === 'flex') {
          helpModal.style.display = 'none';
        } else {
          helpModal.style.display = 'flex';
        }
      }
      if (e.key === 'Escape' && helpModal.style.display === 'flex') {
        helpModal.style.display = 'none';
      }
    });

    // Close help modal on click (if user taps anywhere inside it)
    helpModal.addEventListener('click', function(e) {
      helpModal.style.display = 'none';
    });

    // Back-to-top button functionality
    const backToTop = document.getElementById('back-to-top');
    blogContainer.addEventListener('scroll', function() {
      if (blogContainer.scrollTop > 200) {
        backToTop.style.display = 'flex';
      } else {
        backToTop.style.display = 'none';
      }
    });

    backToTop.addEventListener('click', function() {
      blogContainer.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Add click event to document to deselect when clicking outside
    document.addEventListener('click', function(e) {
      // Check if click is outside any blog post
      if (!e.target.closest('.blog-post')) {
        if (selectedPost) {
          selectedPost.classList.remove('selected');
          selectedPost = null;
        }
      }
    });

    // Add these functions after the existing JavaScript
    const modalOverlay = document.querySelector('.modal-overlay');
    const blogPostModal = document.querySelector('.blog-post-modal');

    function expandBlogPost(post) {
      const title = post.querySelector('h3').textContent;
      const time = post.querySelector('strong').textContent;
      const content = Array.from(post.childNodes)
        .filter(node => !node.querySelector('h3') && !node.querySelector('strong'))
        .map(node => node.outerHTML || node.textContent)
        .join('');
      
      blogPostModal.innerHTML = `
        <strong>${time}</strong>
        <h3>${title}</h3>
        <div class="content">${content}</div>
        <button class="copy-btn">Copy</button>
      `;
      
      // Add copy button event listener for modal
      const modalCopyBtn = blogPostModal.querySelector('.copy-btn');
      modalCopyBtn.addEventListener('click', (e) => copyBlogPost(blogPostModal, e));
      
      // Re-initialize Prism highlighting in the modal
      Prism.highlightAllUnder(blogPostModal);
      
      modalOverlay.style.display = 'block';
      blogPostModal.style.display = 'block';
      document.body.style.overflow = 'hidden';
    }

    function closeExpandedPost() {
      modalOverlay.style.display = 'none';
      blogPostModal.style.display = 'none';
      document.body.style.overflow = '';
    }

    // Add click handlers for closing the expanded post
    modalOverlay.addEventListener('click', closeExpandedPost);
    blogPostModal.addEventListener('click', function(e) {
      e.stopPropagation();
    });

    // Add escape key handler for closing the expanded post
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && blogPostModal.style.display === 'block') {
        closeExpandedPost();
      }
    });

    // Add this function to detect code language
    function detectLanguage(code) {
      // Common language patterns
      const patterns = {
        javascript: /(var|let|const|function|=>|console\.log|document\.|window\.)/,
        python: /(def|import|print|class|if\s+[\w_]+:)/,
        java: /(public|private|class|void|String|int|boolean)/,
        cpp: /(#include|std::|cout|cin|void|int\s+main)/,
        csharp: /(using\s+System|namespace|public\s+class)/,
        html: /(<\/?[a-z][\s\S]*>)/i,
        css: /({[\s\S]*?}|@media|@keyframes|#[\w-]+\s*{)/,
        ruby: /(def|require|puts|attr_|module)/,
        sql: /(SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN)/i
      };

      // Check each pattern
      for (const [language, pattern] of Object.entries(patterns)) {
        if (pattern.test(code)) {
          return language;
        }
      }

      return 'plaintext';
    }

    // Update the formatCodeBlocks function to handle automatic language detection
    function formatCodeBlocks(content) {
      let formattedContent = '';
      
      // Split content into text and potential code blocks
      const lines = content.split('\n');
      let inCodeBlock = false;
      let codeBlock = '';
      let tempContent = '';
      
      lines.forEach((line, index) => {
        // Check for code-like content (indentation or special characters)
        const isCodeLike = /^(\s{4,}|\t+).*$/.test(line) || 
                          /[{}\[\]()$<>]/.test(line) ||
                          /^(const|let|var|function|class|def|import|public|#include)/.test(line);
                          
        if (isCodeLike && !inCodeBlock) {
          // Start a new code block
          if (tempContent) {
            formattedContent += tempContent.replace(/\n/g, '<br>');
            tempContent = '';
          }
          inCodeBlock = true;
          codeBlock = line + '\n';
        } else if (!isCodeLike && inCodeBlock) {
          // End code block
          if (codeBlock) {
            const language = detectLanguage(codeBlock);
            formattedContent += `<pre class="line-numbers"><code class="language-${language}">${
              codeBlock.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .trim()
            }</code></pre>`;
            codeBlock = '';
          }
          inCodeBlock = false;
          tempContent = line + '\n';
        } else if (inCodeBlock) {
          // Continue code block
          codeBlock += line + '\n';
        } else {
          // Continue regular text
          tempContent += line + '\n';
        }
        
        // Handle the last line
        if (index === lines.length - 1) {
          if (inCodeBlock && codeBlock) {
            const language = detectLanguage(codeBlock);
            formattedContent += `<pre class="line-numbers"><code class="language-${language}">${
              codeBlock.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .trim()
            }</code></pre>`;
          } else if (tempContent) {
            formattedContent += tempContent.replace(/\n/g, '<br>');
          }
        }
      });
      
      // Also handle explicit code blocks with backticks if they exist
      formattedContent = formattedContent.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
        const language = lang || detectLanguage(code) || 'plaintext';
        return `<pre class="line-numbers"><code class="language-${language}">${
          code.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .trim()
        }</code></pre>`;
      });
      
      return formattedContent;
    }

    // Replace downloadBlogPost with copyBlogPost
    async function copyBlogPost(post, event) {
      event.stopPropagation(); // Prevent post selection when clicking copy
      
      const copyBtn = event.target;
      copyBtn.classList.add('loading');
      copyBtn.textContent = 'Capturing...';

      try {
        // Create a clone of the post to capture
        const clone = post.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = '0';
        clone.style.left = '0';
        clone.style.margin = '20px';
        clone.style.zIndex = '-1';
        clone.style.transform = 'none';
        document.body.appendChild(clone);

        // Remove the copy button from the clone
        const btnToRemove = clone.querySelector('.copy-btn');
        if (btnToRemove) btnToRemove.remove();

        // Capture the clone
        const canvas = await html2canvas(clone, {
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          scale: 2, // Higher quality
          logging: false,
          allowTaint: true,
          useCORS: true
        });

        // Remove the clone
        document.body.removeChild(clone);

        // Convert to blob and copy to clipboard
        canvas.toBlob(async (blob) => {
          try {
            await navigator.clipboard.write([
              new ClipboardItem({
                'image/png': blob
              })
            ]);
            
            // Show success state
            copyBtn.classList.remove('loading');
            copyBtn.classList.add('success');
            copyBtn.textContent = 'Copied!';
            
            // Reset button after 2 seconds
            setTimeout(() => {
              copyBtn.classList.remove('success');
              copyBtn.textContent = 'Copy';
            }, 2000);
          } catch (error) {
            console.error('Failed to copy:', error);
            copyBtn.classList.remove('loading');
            copyBtn.textContent = 'Copy';
          }
        }, 'image/png');

      } catch (error) {
        console.error('Screenshot failed:', error);
        copyBtn.classList.remove('loading');
        copyBtn.textContent = 'Copy';
      }
    }

    // Fullscreen button functionality for mobile
    if (window.innerWidth < 600) {
      const fullscreenBtn = document.getElementById('fullscreen-btn');
      
      fullscreenBtn.addEventListener('click', function() {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
          document.documentElement.msRequestFullscreen();
        }
      });
    }
  </script>
</body>
</html>
